<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="swiss.css" type="text/css" />
</head>
<body>
<div id="TOC">
<ul>
<li><a href="#introduction">Introduction</a><ul>
<li><a href="#motivation">Motivation</a></li>
<li><a href="#terminology">Terminology</a></li>
<li><a href="#scope">Scope</a></li>
</ul></li>
<li><a href="#protocol">Protocol</a><ul>
<li><a href="#message-types">Message Types</a><ul>
<li><a href="#stream-request">Stream Request</a></li>
<li><a href="#stream-request-response-rollback">Stream Request Response (ROLLBACK)</a></li>
<li><a href="#stream-request-response-ok">Stream Request Response (OK)</a></li>
<li><a href="#partition-stream---snapshot-begin">Partition stream - Snapshot Begin</a></li>
<li><a href="#partition-stream---mutation">Partition stream - Mutation</a></li>
<li><a href="#partition-stream---snapshot-end">Partition stream - Snapshot End</a></li>
</ul></li>
<li><a href="#behaviors">Behaviors</a><ul>
<li><a href="#the-failover-log">The failover log</a></li>
<li><a href="#finding-a-rollback-point">Finding a rollback point</a></li>
</ul></li>
<li><a href="#flow">Flow</a><ul>
<li><a href="#client-flow">Client Flow</a></li>
<li><a href="#server-flow">Server Flow</a></li>
</ul></li>
</ul></li>
</ul>
</div>
<h1 id="introduction"><a href="#introduction">Introduction</a></h1>
<p>See also the framing layer spec (for how requests are paired with responses and streams are managed): <a href="framing.html">framing.html</a></p>
<h2 id="motivation"><a href="#motivation">Motivation</a></h2>
<p>The current replication protocol for Couchbase was designed for the needs of a clustered key-value store. As we've added functionality like indexing and cross datacenter replication, as well as integration with other systems, like Hadoop and ElasticSearch, ... something something (copy edit me help plz)</p>
<h2 id="terminology"><a href="#terminology">Terminology</a></h2>
<dl>
<dt>Partition (sometimes called vBucket)</dt>
<dd><p>Couchbase splits the key space into a fixed amount of partitions, usually 1024. That is, keys are deterministically assigned to a partition, and partitions are assigned to nodes to balance load across the cluster. (renaming the field from the well established name will most likely make it harder to find information why it was created. Please see <a href="http://dustin.github.io/2010/06/29/memcached-vbuckets.html">Dustins blog post</a> describing the vbuckets)</p>
</dd>
<dt>Sequence Number</dt>
<dd><p>Each data event (update, set, delete, etc.) that occurs is assigned a number that can be used to order that event against other events within the same partition. This does <em>not</em> give a cluster-wide ordering of events, but it does enable processes watching events on a partition to resume where they left off after a disconnect.</p>
</dd>
<dt>Partition Version</dt>
<dd><p>A UUID, Sequence Number pair associated with a partition. A new version is assigned to a partition by its new master node any time there may have been a history branch, with the sequence number being the highest snapshotted sequence seen in that partition by its master node.</p>
</dd>
<dt>History Branch</dt>
<dd><p>Whenever a node becomes the master node for a partition, if it was not the farthest ahead of all processes watching events on that partition and starts taking mutations, it is possible it will reuse sequence numbers that other processes have already seen on this partition.</p>
</dd>
</dl>
<h2 id="scope"><a href="#scope">Scope</a></h2>
<p>The new intra-cluster replication protocol should provide an ordering of events in a partition, even across cluster topology changes. This allows a client of the protocol to correctly resume from where it left off, avoiding unnecessary network load or index computation.</p>
<p>The protocol should also specify how to handle cases where components in the cluster disagree on the history events in a partition.</p>
<h1 id="protocol"><a href="#protocol">Protocol</a></h1>
<h2 id="message-types"><a href="#message-types">Message Types</a></h2>
<h3 id="stream-request"><a href="#stream-request">Stream Request</a></h3>
<p>A client is requesting the event stream for a partition since some sequence. It sends the known versions of the partition, with the most recent one it was connected to first.</p>
<p>If the client's most recently connected-to version for the partition is <em>not</em> the current one on the server, the server will determine how far the client must roll back to sync up with the now current version of this partition.</p>
<p>Clients that try to stay connected as often as possible likely only need to keep the most recent partition version for the partitions they are watching, whereas clients that connect rarely (for example, a backup process), may want to keep several partition versions, which allows for finding a better rollback point than zero when multiple history branches have occurred since the last time the client was connected.</p>
<h4 id="fields"><a href="#fields">Fields</a></h4>
<ul>
<li>Partition to stream from</li>
<li>Sequence number to stream since</li>
<li>Client's known versions for the partition</li>
<li>Does the client want the entire version log?</li>
</ul>
<h3 id="stream-request-response-rollback"><a href="#stream-request-response-rollback">Stream Request Response (ROLLBACK)</a></h3>
<p>There has been a history branch since the client was last connected, so the server sends it sequence number.</p>
<p>The client must roll back data such that it's state is as of a snapshot that ends on a sequence <em>less than or equal</em> to this sequence.</p>
<h4 id="fields-1"><a href="#fields-1">Fields</a></h4>
<ul>
<li>Sequence number to roll back (at least) to.</li>
</ul>
<h3 id="stream-request-response-ok"><a href="#stream-request-response-ok">Stream Request Response (OK)</a></h3>
<p>There was no history branch since the client last connected, or the client is requesting the entire history (change since sequence zero). The server will now start streaming the requested items.</p>
<h4 id="fields-2"><a href="#fields-2">Fields</a></h4>
<ul>
<li>Current partition version, or all the versions the server knows about if the client requested them.</li>
<li>Stream identifier for this partition stream</li>
</ul>
<h3 id="partition-stream---snapshot-begin"><a href="#partition-stream---snapshot-begin">Partition stream - Snapshot Begin</a></h3>
<p>This message is sent to notify the snapshot the items that follow are in a snapshot, meaning that only the most recent update for any given key within the snapshot window.</p>
<h4 id="fields-3"><a href="#fields-3">Fields</a></h4>
<ul>
<li>Sequence number at which this snapshot ends</li>
</ul>
<h3 id="partition-stream---mutation"><a href="#partition-stream---mutation">Partition stream - Mutation</a></h3>
<p>An item update, always has a key, may represent a delete, in which case there will not be a value.</p>
<h4 id="fields-4"><a href="#fields-4">Fields</a></h4>
<ul>
<li>Sequence number</li>
<li>Key</li>
<li>Value?</li>
<li>Deleted?</li>
<li>... what other metadata?</li>
</ul>
<h3 id="partition-stream---snapshot-end"><a href="#partition-stream---snapshot-end">Partition stream - Snapshot End</a></h3>
<p>This message will be sent after all items in a snapshot have been sent, to let the client know the snapshot is complete.</p>
<h2 id="behaviors"><a href="#behaviors">Behaviors</a></h2>
<h3 id="the-failover-log"><a href="#the-failover-log">The failover log</a></h3>
<p>When a replica requests partition streams it should ask the master for a list of all of versions of that partition the master node knows about.</p>
<p>The replica will keep that list in case it becomes master and needs to send the version history to other replicas in the future.</p>
<p>When a node takes over as master for a partition, if it creates a new version for that partition (because it was not able to take over cleanly), it adds an entry to the partition version list that it maintains. This is also called the failover log, since it will have an entry for each failover, or unclean takeover, event.</p>
<h3 id="finding-a-rollback-point"><a href="#finding-a-rollback-point">Finding a rollback point</a></h3>
<p>When a client connects and has not been most recently connected to the current version of the partition it is requesting, the server should search for the provided version in its failover log. If it finds an entry for that version, it should send a message to the client requesting it roll back <em>at least to</em> the sequence that begins the version <em>after</em> this version in the failover log.</p>
<p>If none of the clients known versions can be found in the server's failover log, it must request that the client roll back to zero, that is, discard all its data for this partition and start from scratch.</p>
<h2 id="flow"><a href="#flow">Flow</a></h2>
<div class="figure">
<img src="flow0.svg" alt="Client and Server Flow" /><p class="caption">Client and Server Flow</p>
</div>
<h3 id="client-flow"><a href="#client-flow">Client Flow</a></h3>
<ol style="list-style-type: decimal">
<li>To begin receiving items for a partition, a client must send a Stream Request message, indicating the partition it wants to receive items for, the last sequence it received the last time it was connected (or 0 otherwise), and if it was connected before, the identifier for the last version of the partition it received items from.</li>
<li><p>The client waits for a response.</p>
<ul>
<li><p>The client may receive an OK response, notifying it that a stream has been started on which it will receive item and snapshot messages.</p></li>
<li>Or, the client may receive a ROLLBACK response, notifying it that there has been a history branch on this partition since it was last connected, and a sequence that must be rolled back <em>at least</em> to. The client may roll back to a sequence that is <em>earlier</em> than that sequence. The server will <strong>not</strong> send changes after a ROLLBACK response, and the client should send another Stream Request after it has completed its rollback operation if it still wants items for this partition.</li>
</ul></li>
<li>The client got an OK response, and begins listening for messages on the stream identified by the OK response message.</li>
<li>The client should receive a Snapshot Begin message, indicating that the items that follow, until a Snapshot End message is received, will contain at <em>most</em> one version of any particular key, which will be the <em>latest</em> version of that key as of the sequence number included in the Snapshot Begin message.</li>
<li>The client receives items.</li>
<li><p>The client receives a Snapshot End message, indicating that it has now been sent the latest updates for all keys that were updated between the sequence it requested in its Stream Request and the highest sequence number in this snapshot. The client should now wait for another Snapshot Begin message (#4)</p></li>
</ol>
<h3 id="server-flow"><a href="#server-flow">Server Flow</a></h3>
</body>
</html>
